/*
 * adc.c
 *
 *  Created on: Oct 23, 2023
 *      Author: HP
 */
#include "adc.h"
#include "ADC_config.h"
#include "AvrRegisters.h"
#include "bitmap.h"

void (*CallbackPtr_adc )(void)=NULL;


void ADC_init(){

#if (AUTO_TRIGGER_ENABLE==1)
	SET_BIT(ADCSRA,ADATE_ID);
#if (ADC_AUTO_TRIGGER_SOURCE==FREE_RUNNING_MODE)
	SET_BIT(ADCSRA,ADSC_ID); /***START CONVERSION IN INIT AT FIRST***/
	CLEAR_BIT(SFIOR,ADTS2_ID);
	CLEAR_BIT(SFIOR,ADTS1_ID);
	CLEAR_BIT(SFIOR,ADTS0_ID);
#elif(ADC_AUTO_TRIGGER_SOURCE==ANALOG_COMP)
	CLEAR_BIT(SFIOR,ADTS2_ID);
	CLEAR_BIT(SFIOR,ADTS1_ID);
	SET_BIT(SFIOR,ADTS0_ID);
#elif (ADC_AUTO_TRIGGER_SOURCE==EXTERNAL_INT)
	CLEAR_BIT(SFIOR,ADTS2_ID);
	SET_BIT(SFIOR,ADTS1_ID);
	CLEAR_BIT(SFIOR,ADTS0_ID);
#elif (ADC_AUTO_TRIGGER_SOURCE==TIMER0_COMP)
	CLEAR_BIT(SFIOR,ADTS2_ID);
	SET_BIT(SFIOR,ADTS1_ID);
	SET_BIT(SFIOR,ADTS0_ID);
#elif(ADC_AUTO_TRIGGER_SOURCE==TIMER0_OVERFLOW)
	SET_BIT(SFIOR,ADTS2_ID);
	CLEAR_BIT(SFIOR,ADTS1_ID);
	CLEAR_BIT(SFIOR,ADTS0_ID);
#elif (ADC_AUTO_TRIGGER_SOURCE==TIMER1_COMP)
	SET_BIT(SFIOR,ADTS2_ID);
	CLEAR_BIT(SFIOR,ADTS1_ID);
	SET_BIT(SFIOR,ADTS0_ID);
#elif(ADC_AUTO_TRIGGER_SOURCE==TIMER1_OVERFLOW)
	SET_BIT(SFIOR,ADTS2_ID);
	SET_BIT(SFIOR,ADTS1_ID);
	CLEAR_BIT(SFIOR,ADTS0_ID);
#elif(ADC_AUTO_TRIGGER_SOURCE==TIMER1_CAPTURE)
	SET_BIT(SFIOR,ADTS2_ID);
	SET_BIT(SFIOR,ADTS1_ID);
	SET_BIT(SFIOR,ADTS0_ID);
#endif //ADC_AUTO_TRIGGER_SOURCE
#elif(AUTO_TRIGGER_ENABLE==0)
	CLEAR_BIT(ADCSRA,ADATE_ID);
#endif // (AUTO_TRIGGER_ENABLE==1)
#if(VOLTAGE_REFERENCE==AVCC)
	SET_BIT(ADMUX,REFS0_ID);
	CLEAR_BIT(ADMUX,REFS1_ID);
#elif(VOLTAGE_REFERENCE==AREF)
	CLEAR_BIT(ADMUX,REFS0_ID);
	CLEAR_BIT(ADMUX,REFS1_ID);
#elif (VOLTAGE_REFERENCE==INTRENAL)
	SET_BIT(ADMUX,REFS0_ID);
	SET_BIT(ADMUX,REFS1_ID);
#endif
#if (ADJUSTMENT==RIGHT_ADJUSTMENT)
	SET_BIT(ADMUX,ADLAR_ID);
#elif (ADJUSTMENT==LEFT_ADJUSTMENT)
	CLEAR_BIT(ADMUX,ADLAR_ID);
#endif
///* SINGLE ENDED MODE MUX4=0 MUX3=0*/
//	CLEAR_BIT(ADMUX,MUX4_ID);
//	CLEAR_BIT(ADMUX,MUX3_ID);
//#if (ADC_CHANNEL_NUMBER==DIO_U8_PIN_0)
//	CLEAR_BIT(ADMUX,MUX4_ID);
//	CLEAR_BIT(ADMUX,MUX3_ID);
//	CLEAR_BIT(ADMUX,MUX2_ID);
//	CLEAR_BIT(ADMUX,MUX1_ID);
//	CLEAR_BIT(ADMUX,MUX0_ID);
//#elif(ADC_CHANNEL_NUMBER==DIO_U8_PIN_1)
//	CLEAR_BIT(ADMUX,MUX2_ID);
//	CLEAR_BIT(ADMUX,MUX1_ID);
//	SET_BIT(ADMUX,MUX0_ID);
//#elif(ADC_CHANNEL_NUMBER==DIO_U8_PIN_2)
//	CLEAR_BIT(ADMUX,MUX2_ID);
//	SET_BIT(ADMUX,MUX1_ID);
//	CLEAR_BIT(ADMUX,MUX0_ID);
//#elif(ADC_CHANNEL_NUMBER==DIO_U8_PIN_3)
//	CLEAR_BIT(ADMUX,MUX2_ID);
//	SET_BIT(ADMUX,MUX1_ID);
//	SET_BIT(ADMUX,MUX0_ID);
//#elif(ADC_CHANNEL_NUMBER==DIO_U8_PIN_4)
//	SET_BIT(ADMUX,MUX2_ID);
//	CLEAR_BIT(ADMUX,MUX1_ID);
//	CLEAR_BIT(ADMUX,MUX0_ID);
//#elif(ADC_CHANNEL_NUMBER==DIO_U8_PIN_5)
//	SET_BIT(ADMUX,MUX2_ID);
//	CLEAR_BIT(ADMUX,MUX1_ID);
//	SET_BIT(ADMUX,MUX0_ID);
//#elif(ADC_CHANNEL_NUMBER==DIO_U8_PIN_6)
//	SET_BIT(ADMUX,MUX2_ID);
//	SET_BIT(ADMUX,MUX1_ID);
//	CLEAR_BIT(ADMUX,MUX0_ID);
//#elif(ADC_CHANNEL_NUMBER==DIO_U8_PIN_7)
//	SET_BIT(ADMUX,MUX2_ID);
//	SET_BIT(ADMUX,MUX1_ID);
//	SET_BIT(ADMUX,MUX0_ID);
//#endif
#if (ADC_PRESCALLER==DIVID_BY_2)
	CLEAR_BIT(ADCSRA,ADPS2_ID);
	CLEAR_BIT(ADCSRA,ADPS1_ID);
	SET_BIT(ADCSRA,ADPS0_ID);
#elif (ADC_PRESCALLER==DIVID_BY_4)
	CLEAR_BIT(ADCSRA,ADPS2_ID);
	SET_BIT(ADCSRA,ADPS1_ID);
	CLEAR_BIT(ADCSRA,ADPS0_ID);

#elif (ADC_PRESCALLER==DIVID_BY_8)
	CLEAR_BIT(ADCSRA,ADPS2_ID);
	SET_BIT(ADCSRA,ADPS1_ID);
	SET_BIT(ADCSRA,ADPS0_ID);
#elif (ADC_PRESCALLER==DIVID_BY_16)
	SET_BIT(ADCSRA,ADPS2_ID);
	CLEAR_BIT(ADCSRA,ADPS1_ID);
	CLEAR_BIT(ADCSRA,ADPS0_ID);
#elif (ADC_PRESCALLER==DIVID_BY_32)
	SET_BIT(ADCSRA,ADPS2_ID);
	CLEAR_BIT(ADCSRA,ADPS1_ID);
	SET_BIT(ADCSRA,ADPS0_ID);
#elif (ADC_PRESCALLER==DIVID_BY_64)
	SET_BIT(ADCSRA,ADPS2_ID);
	SET_BIT(ADCSRA,ADPS1_ID);
	CLEAR_BIT(ADCSRA,ADPS0_ID);
#elif (ADC_PRESCALLER==DIVID_BY_128)
	SET_BIT(ADCSRA,ADPS2_ID);
	SET_BIT(ADCSRA,ADPS1_ID);
	SET_BIT(ADCSRA,ADPS0_ID);
#endif

	ADC_voidEnable();
}
void ADC_voidEnable(){
	SET_BIT(ADCSRA,ADEN_ID);
}

void ADC_voidDisable(){
	CLEAR_BIT(ADCSRA,ADEN_ID);
}
u16 ADC_u16ReadADC(void){
#if (AUTO_TRIGGER_ENABLE==0)
	while (BIT_IS_SET(ADCSRA,ADSC_ID));
	return ADC;
#elif (AUTO_TRIGGER_ENABLE==1)
	return ADC;
#endif
}
void ADC_voidStartConversion(u8 channel_num){
	channel_num &=0x07;
	ADMUX &=0XE0;
	ADMUX = ADMUX | channel_num;
	SET_BIT(ADCSRA,ADSC_ID);
}
void ADC_voidEnableInt(){
	SET_BIT(ADCSRA,ADIE_ID);
}
void ADC_voidDisableInt(){
	CLEAR_BIT(ADCSRA,ADIE_ID);
}
void ADC_SetCallback( void (*ptr) (void) ){
	CallbackPtr_adc=ptr;
}
void __vector_16(void) __attribute__ ((signal,used, externally_visible));
void __vector_16(){

	if (CallbackPtr_adc!=NULL)
	CallbackPtr_adc();
}
u16 ADC_u16ReadADCInMV(){
	u16 analog_mv,data;
	data = ADC_u16ReadADC();
	analog_mv = (5000ul*data)/1024;
	return analog_mv;
}
